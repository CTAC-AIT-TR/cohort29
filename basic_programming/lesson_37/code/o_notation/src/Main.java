public class Main {

    /*
    Сложность алгоритмов.

    Cложность алгоритма - это всего лишь способ измерить  насколько быстро программа работает
    Алгоритмы сравниваются с точки зрения того, как происходит вычисление, без учета железа или языка прграммирования
    на котором программа написана

    Анализ сложности позволяет узнать  насколько быстрой является программа при выполнении вычислений и позволяет
    обьяснить как будет вести себя алгоритм при возрастании входного потока данных
     */
    public static void main(String[] args) {
        drawTriangle(5);
        char theta = '\u03f4';
        System.out.println(theta);
    }

    // {1,2,3,4}
    // 4,3,2,1
    public int max ( int[]ints,int n){
        int max = ints[0]; // 2 действия. Поиск ints[0]  и присвоение. Выполняются всегда, независимо от размера массива

        for( int i = 0;i<n;i++){ //  присвоение начального значения и сравнение с n  тоже всегда выполняются = еще 2
            if(ints[i]>max){
                max = ints[i];
            } // на каждой итерации цикла происходят еще 2 действия - увеличение i  и сравнение с n
        }
        return max;
    }

    // без учета содержимого в теле цикла количество инструкций у этого алгоритма 4 + 2n
    // f(n)= 4 + 2n   для цикла с пустым телом
    // 4 + 2n+4n   - это количество команд с учетом тела цикла в наихудшем случае, когда тело if  выполняется
    // каждый раз
    /*
    f(n) = 4 +6n

    В анализе сложности важно то, что происходит с функцией при сильном возрастании n. Поэтому мы можем отбросить
    те части функции, которые при сильном росте n растут медленно или совсем не растут. Поэтому 4 мы отбрасываем,
    т.к. это константа

    f(n) = 6n // 6 тоже отбрасываем

    f(n) = n

    1. f(n) = 3n +15    ->  f(n) = n
    2. f(n) = 214       ->   f(n) = 1   // 214*1 и 214 отбравсываем
    3. f(n) = n^2 + 4n + 54   f(n) = n^2
    4. f(n) = n^3 + 2100n + 582    f(n) = n^3
    5. f(n) = n +sqrt(n)           f(n) = n

    //Сложность
     */

    public boolean linSearch ( int[] arr,int eltToFind){
        for(int i = 0; i < arr.length;i++){
            if(arr[i] == eltToFind)
                return true;
        }
        return false;
    }

    public int sum( int a, int b){
        int res = a+b;

        return res;
    }

    public static void drawTriangle(int n){
        for( int i = 1;i<=n;i++){
            for( int j=1;j<=i;j++){
                System.out.print(j);

            }
            System.out.println();
        }
    }

    // простые программы можно анализировать с помощью подсчета в них количества вложенных циклов.
    // одиночный f(n) = n,    цикл внутри цикла f(n) = n^2  , и т.д

    //ϴ(1),  f(n)= 2n +1   ->  ϴ(n)

   // Нотация  "большое О "

}
